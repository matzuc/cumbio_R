---
title: "Cumulative Biomass / Production"
author: "MZ https://github.com/matzuc"
format:
  html:
    embed-resources: true
execute:
  message: false
---

This notebook is available at <https://github.com/matzuc>

## Dependancies

loading required packages for running the example. For fitting the curves and estimating the parameters, only the `drc` package is needed.

```{r warning=F, message=F}
library(drc)
library(dplyr) # data handling
library(tidyr) # data handling
library(purrr) # data handling
library(ggplot2) # plotting
library(ggthemes) # plotting
library(viridis) # plotting
library(here) # handling paths

```

## Loading the dataset

We use the procedure from [ecobase.ecopath.org](http://ecobase.ecopath.org/#docs "http://ecobase.ecopath.org/#docs") to read an *Ecopath* model

```{r warning=F}
library(RCurl)
library(XML)
library(plyr)

```

get the list of models

```{r}

#To obtain the list of available model
h=basicTextGatherer()
curlPerform(url = 'http://sirs.agrocampus-ouest.fr/EcoBase/php/webser/soap-client_3.php',writefunction=h$update)

data<-xmlTreeParse(h$value(),useInternalNodes=TRUE)
liste_mod<-ldply(xmlToList(data),data.frame)%>% filter(model.dissemination_allow =='true')
        
liste_mod #contains a list and decription of available models in EcoBase  
```

## Data handling

I extract the mode **112** for the North Atlantic (1994)

```{r message=F}

#To Obtain a model - output
h=basicTextGatherer()
mymodel<-736

curlPerform(url = paste('http://sirs.agrocampus-ouest.fr/EcoBase/php/webser/soap-client_output.php?no_model=',mymodel,sep=''),writefunction=h$update,verbose=TRUE)


data<-xmlTreeParse(h$value(),useInternalNodes=TRUE)

output1<-xpathSApply(data,'//group',function(x) xmlToList(x))
        
```

arrange the dataset

```{r}
dat <- t(output1) |> as.data.frame()
```



Check for duplicates

### Cumulating biomass

We group the TLs in TL classes, choosing a 0.1 step, and cumulating the biomass for each TL class, groupting for EEZ and year

Cumulated biomass for TL (no TL class, here)

```{r}

cumbio <- dat |> 
	mutate(p = as.numeric(biomass) * as.numeric(pb),
				 tl = as.numeric(tl)) |>
	arrange(tl) |> # order by TL
	filter(tl > 2) |>
	mutate(ycum = cumsum(as.numeric(biomass)), pcum = cumsum(p)) |> # cumulative biomass
	mutate(ycurv = ycum / max(ycum), pcurv = pcum/max(pcum)) #relative cumulative biomass
	

```

We can plot all the curves 

```{r}
ggplot(cumbio, aes(tl, ycurv)) +
	geom_point(alpha = 0.5, size = 0.6) + 
	geom_line(alpha = 0.5) +
	theme_few() +
	xlab("TL") +
	ylab("Relative Cumulative Biomass") +
	ggtitle("Observed cumulative biomass curves")

```



```{r}
ggplot(cumbio, aes(ycurv, pcurv)) +
	geom_point(alpha = 0.5, size = 0.6) + 
	geom_line(alpha = 0.5) +
	theme_few() +
	ylab("Relative Cumulative Production") +
	xlab("Relative Cumulative Biomass") +
	ggtitle("cumB/cumP") 

```




# fit the curve

```{r}
library(segmented)
library(nlme)
data(Cefamandole)
Cefamandole$lTime <-log(Cefamandole$Time)
Cefamandole$lconc <-log(Cefamandole$conc)
plot(Cefamandole$lTime, Cefamandole$lconc)

o<-lm(lconc ~ lTime, data=Cefamandole)
os<-segmented.lm(o, ~lTime, #random=list(Subject=pdDiag(~1+lTime+U+G0)),
control=seg.control(n.boot=0, display=TRUE))
slope(os)
plot(os)
os
o
```

```{r}
oo <- lm(pcurv ~ ycurv, data=cumbio)
ooss <- segmented.lm(oo, ~ ycurv, data=cumbio,
control=seg.control(n.boot=0, display=TRUE))
ooss

plot(ooss)



```


grafico

```{r}
pr <-data.frame(ycurv = cumbio$ycurv, p = predict(ooss))


ggplot(cumbio, aes(ycurv, pcurv)) +
	geom_point(alpha = 0.5, size = 0.6) + 
	geom_line(alpha = 0.5) +
	theme_few() +
	ylab("Relative Cumulative Production") +
	xlab("Relative Cumulative Biomass") +
	ggtitle("cumB/cumP") +
	geom_line(data = pr, aes(y = p), col = "red", lty = 2)

pr
```



or just focus on one curve:

```{r}
ex <- cumbio |> filter(area_name == "Sicily (Italy)", year == 2015)

ex_plot <- ggplot(ex, aes(fTLr, ycurv)) +
	geom_point(alpha = 0.5, size = 0.6) + 
	geom_line(alpha = 0.5, lty = 3) +
	facet_grid(.~ area_name) +
	theme_few() +
	xlab("TL") +
	ylab("Relative Cumulative Biomass") +
	ggtitle("Observed cumulative biomass curves")

print(ex_plot)
```

## Fit the curves and extract the parameters

we can leverage the `baro5` function from the `drc` package to fit the baroreflex 5-parameter function to the TL/ relative cumulative biomass relationship

We can define a function to fit the model (fixing the upper asymptote to 1), and extract some parameters to summarize the characteristics of the curve

```{r}

mycurve <- function(x, y, npoints = 10000){
	
	# fit the model
  r <- drm(y ~ x, fct = baro5(fixed = c(NA, NA, NA, 1, NA)))

  # use the fitted curve to predict the expected values (these are used fot plotting and estimating the parameters)
  
  # xx are the TLs
  xx <- NA;
  xx <- seq(1.6, 5,length.out = npoints)
  pr <- NA; length(pr) <- npoints# vector for prediction
  pr <- predict(r, newdata = data.frame(x = xx))
  
  # parameters
  
  dpr<-diff(pr,1)/diff(xx)
  
  # TL @ inflection point 
  TLinfl <- xx[which.max(dpr)-1]
  # maximum steepness
  Steepness <- max(dpr)
  # Biomass @ inflection
  BIOinfl<- predict(r, newdata=data.frame(x = TLinfl)) 
  # Lower asymptote
  LowA <- predict(r, newdata=data.frame(x=1))

  
  
  
  results <- list(
  	curve = data.frame(x = xx, y = pr),
  	parameters = 	data.frame(LowA = LowA, Steepness = Steepness, TLinfl = TLinfl, BIOinfl = BIOinfl) 
  )
  	
  return(results)
  
  
}

```

We use the function on the small example

```{r}
out_ex <- mycurve(ex$fTLr, ex$ycurv)
```

And see how the curve looks like

```{r}
ex_plot <- ex_plot +
	geom_line(data = out_ex$curve, aes(x = x, y = y), size = 1.1, alpha = 0.6) +
	ggtitle("Fitted curve")

print(ex_plot)
```

We can also visualize the extracted parameters

```{r}

intercept <- out_ex$parameters$BIOinfl - out_ex$parameters$Steepness * out_ex$parameters$TLinfl

ex_plot <- ex_plot  +
	geom_abline(aes(intercept = intercept, slope = out_ex$parameters$Steepness), colour = "blue", lty = 2, alpha = 0.8) +
	geom_segment(data = out_ex$parameters, aes(x = TLinfl, y = BIOinfl,
									 xend = min(out_ex$curve$x), yend = BIOinfl), size = 0.8, lty = 1, alpha = 0.8, colour = "green", arrow=arrow()) +
	geom_segment(data = out_ex$parameters, aes(x = TLinfl, y = BIOinfl,
									 xend = TLinfl, yend = 0), size = 0.8, lty = 1, alpha = 0.8, colour = "green", arrow=arrow()) +
	geom_point(data = out_ex$parameters, aes(x = TLinfl, y = BIOinfl), colour = "red", size = 1.6) 

print(ex_plot)
```

the function can be used also on the time series

```{r warning=F}

out_pars <- cumbio |> 
	group_by(area_name, year) |> 
	summarise(LowA = mycurve(fTLr, ycurv)$parameters$LowA,
						Steepness = mycurve(fTLr, ycurv)$parameters$Steepness,
						TLinfl = mycurve(fTLr, ycurv)$parameters$TLinfl,
						BIOinfl = mycurve(fTLr, ycurv)$parameters$BIOinfl)
```

We can plot the time series of the parameters

```{r}
longdata <- out_pars |> 
  tidyr::gather(variable, value, c(LowA, Steepness, TLinfl, BIOinfl)) %>% 
  group_by(area_name, year) %>% 
  #summarise(mean_value = mean(value)) %>% 
  ungroup()

ggplot(longdata, aes(year, value)) +
	geom_point(alpha = 0.7) +
	geom_line(alpha = 0.7) +
	facet_grid(variable ~ area_name, scale = "free_y") +
	theme_few() +
	ylab("Parameter value")
```

We can also extract all the fitted curves and plot them

```{r warning = F}
b_curves <- cumbio  %>%
  # Group the data by area_name and year
  group_by(area_name, year) %>%
  # Split the data into a list of data frames based on the grouping
  group_split() %>%
  # Apply the mycurve function to each data frame in the list
  map(function(df) {
    # Apply the function using fTLr as x and ycurv as y
    res <- mycurve(df$fTLr, df$ycurv, npoints = 100)
    
    # Extract the curve data frame
    curve <- res$curve
    
    # Add area_name and year columns to the curve data frame
    curve$area_name <- unique(df$area_name)
    curve$year <- unique(df$year)
    
    # Return the curve data frame
    curve
  }) %>%
  # Combine the curve data frames from each list element
  bind_rows()


ggplot(b_curves, aes(x, y, colour = year, group = (year))) +
	geom_line(alpha = 0.5) +
	facet_grid(.~ area_name) +
	scale_color_viridis_c(option = "magma") +
	theme_few() +
	xlab("TL") +
	ylab("Relative Cumulative Biomass") +
	ggtitle("Fitted cumulative biomass curves") +
	geom_point(data = out_pars, aes(x = TLinfl, y =  BIOinfl), alpha = 0.4, size = 0.7)

```
